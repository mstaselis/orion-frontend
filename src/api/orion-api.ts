/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.0.0 (NJsonSchema v10.1.24.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export interface IClient {
    /**
     * Retrieve API Resources
     */
    retrieve_API_Resources(): Promise<OrionResponse<RetrieveApiResourcesResponse>>;
    /**
     * List Entities
     * @param id (optional) A comma-separated list of elements.
    Retrieve entities whose ID matches one of the elements in the list.
    Incompatible with `idPattern`.
     * @param type (optional) comma-separated list of elements.
    Retrieve entities whose type matches one of the elements in the list.
    Incompatible with `typePattern`.
     * @param idPattern (optional) A correctly formated regular expression.
    Retrieve entities whose ID matches the regular expression. Incompatible with `id`.
     * @param typePattern (optional) A correctly formated regular expression.
    Retrieve entities whose type matches the regular expression. Incompatible with `type`.
     * @param q (optional) A query expression, composed of a list of statements
    separated by `;`, i.e., q=statement1;statement2;statement3.
    See [Simple Query Language specification](#simple_query_language).
     * @param mq (optional) A query expression for attribute metadata,
    composed of a list of statements separated by `;`, i.e., mq=statement1;statement2;statement3.
    See [Simple Query Language specification](#simple_query_language).
     * @param georel (optional) Spatial relationship between matching entities and a
    reference shape. See [Geographical Queries](#geographical_queries).
     * @param geometry (optional) Geografical area to which the query is restricted.
    See [Geographical Queries](#geographical_queries).
     * @param coords (optional) List of latitude-longitude
    pairs of coordinates separated by ';'. See [Geographical Queries](#geographical_queries).
     * @param limit (optional) Limits the number of entities to be retrieved
     * @param offset (optional) Establishes the offset from where entities are retrieved
     * @param attrs (optional) Comma-separated list of attribute names whose data
    are to be included in the response.
    The attributes are retrieved in the order specified by this parameter. If this parameter is
    not included, the attributes are retrieved in arbitrary order.
    See "Filtering out attributes and metadata" section for more detail.
     * @param metadata (optional) A list of metadata names to include in the response.
    See "Filtering out attributes and metadata" section for more detail.
     * @param orderBy (optional) Criteria for ordering results.
    See "Ordering Results" section for details.
     * @param options (optional) Options dictionary
     */
    list_Entities(id?: string | null | undefined, type?: string | null | undefined, idPattern?: string | null | undefined, typePattern?: string | null | undefined, q?: string | null | undefined, mq?: string | null | undefined, georel?: string | null | undefined, geometry?: string | null | undefined, coords?: string | null | undefined, limit?: number | null | undefined, offset?: number | null | undefined, attrs?: string | null | undefined, metadata?: string | null | undefined, orderBy?: string | null | undefined, options?: Options2 | null | undefined): Promise<OrionResponse<ListEntitiesResponse[]>>;
    /**
     * Create Entity
     * @param options (optional) Options dictionary
     */
    create_Entity(content_Type: string, body: CreateEntityRequest, options?: Options4 | null | undefined): Promise<OrionResponse<void>>;
    /**
     * Retrieve Entity
     * @param entityId Id of the entity to be retrieved
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param attrs (optional) Comma-separated list of attribute names whose
    data must be included in the response. The attributes are retrieved in the order specified by
    this parameter. See "Filtering out attributes and metadata" section for more detail.
    If this parameter is not included, the attributes are retrieved in arbitrary order, and all
    the attributes of the entity are included in the response.
     * @param metadata (optional) A list of metadata names to include in the response.
    See "Filtering out attributes and metadata" section for more detail.
     * @param options (optional) Options dictionary
     */
    retrieve_Entity(entityId: string, type?: string | null | undefined, attrs?: string | null | undefined, metadata?: string | null | undefined, options?: Options5 | null | undefined): Promise<OrionResponse<RetrieveEntityResponse>>;
    /**
     * Remove Entity
     * @param entityId Id of the entity to be deleted
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     */
    remove_Entity(entityId: string, type?: string | null | undefined): Promise<OrionResponse<void>>;
    /**
     * Retrieve Entity Attributes
     * @param entityId Id of the entity to be retrieved
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param attrs (optional) Comma-separated list of attribute names whose
    data are to be included in the response. The attributes are retrieved in the order specified
    by this parameter.
    If this parameter is not included, the attributes are retrieved in arbitrary order, and all
    the attributes of the entity are included in the response.
    See "Filtering out attributes and metadata" section for more detail.
     * @param metadata (optional) A list of metadata names to include in the response.
    See "Filtering out attributes and metadata" section for more detail.
     * @param options (optional) Options dictionary
     */
    retrieve_Entity_Attributes(entityId: string, type?: string | null | undefined, attrs?: string | null | undefined, metadata?: string | null | undefined, options?: Options7 | null | undefined): Promise<OrionResponse<RetrieveEntityAttributesResponse>>;
    /**
     * Replace all entity attributes
     * @param entityId Id of the entity in question.
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param options (optional) Operations options
     */
    replace_all_entity_attributes(entityId: string, content_Type: string, body: ReplaceAllEntityAttributesRequest, type?: string | null | undefined, options?: Options8 | null | undefined): Promise<OrionResponse<void>>;
    /**
     * Update or Append Entity Attributes
     * @param entityId Entity id to be updated
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param options (optional) Operations options
     */
    update_or_Append_Entity_Attributes(entityId: string, content_Type: string, body: UpdateOrAppendEntityAttributesRequest, type?: string | null | undefined, options?: Options9 | null | undefined): Promise<OrionResponse<void>>;
    /**
     * Update Existing Entity Attributes
     * @param entityId Id of the entity to be updated
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param options (optional) Operations options
     */
    update_Existing_Entity_Attributes(entityId: string, content_Type: string, body: UpdateExistingEntityAttributesRequest, type?: string | null | undefined, options?: Options11 | null | undefined): Promise<OrionResponse<void>>;
    /**
     * Get attribute data
     * @param entityId Id of the entity
     * @param attrName Name of the attribute to be retrieved.
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param metadata (optional) A list of metadata names to include in the response.
    See "Filtering out attributes and metadata" section for more detail.
     */
    get_attribute_data(entityId: string, attrName: string, type?: string | null | undefined, metadata?: string | null | undefined): Promise<OrionResponse<GetAttributeDataResponse>>;
    /**
     * Update Attribute Data
     * @param entityId Id of the entity to update
     * @param attrName Attribute name
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     */
    update_Attribute_Data(entityId: string, attrName: string, content_Type: string, body: UpdateAttributeDataRequest, type?: string | null | undefined): Promise<OrionResponse<void>>;
    /**
     * Remove a Single Attribute
     * @param entityId Id of the entity.
     * @param attrName Attribute name.
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     */
    remove_a_Single_Attribute(entityId: string, attrName: string, type?: string | null | undefined): Promise<OrionResponse<void>>;
    /**
     * Get Attribute Value
     * @param entityId Id of the entity in question
     * @param attrName Name of the attribute to be retrieved.
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     */
    get_Attribute_Value(entityId: string, attrName: string, type?: string | null | undefined): Promise<OrionResponse<GetAttributeValueResponse>>;
    /**
     * Update Attribute Value
     * @param entityId Id of the entity to be updated.
     * @param attrName Attribute name.
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     */
    update_Attribute_Value(entityId: string, attrName: string, content_Type: string, body: UpdateAttributeValueRequest, type?: string | null | undefined): Promise<OrionResponse<void>>;
    /**
     * List Entity Types
     * @param limit (optional) Limit the number of types to be retrieved.
     * @param offset (optional) Skip a number of records.
     * @param options (optional) Options dictionary.
     */
    list_Entity_Types(limit?: number | null | undefined, offset?: number | null | undefined, options?: Options13 | null | undefined): Promise<OrionResponse<ListEntityTypesResponse[]>>;
    /**
     * Retrieve entity type
     * @param entityType Entity Type
     */
    retrieve_entity_type(entityType: string): Promise<OrionResponse<RetrieveEntityTypeResponse>>;
    /**
     * List Subscriptions
     * @param limit (optional) Limit the number of subscriptions to be retrieved
     * @param offset (optional) Skip a number of subscriptions
     * @param options (optional) Options dictionary
     */
    list_Subscriptions(limit?: number | null | undefined, offset?: number | null | undefined, options?: Options14 | null | undefined): Promise<OrionResponse<ListSubscriptionsResponse[]>>;
    /**
     * Create Subscription
     */
    create_Subscription(content_Type: string, body: CreateSubscriptionRequest): Promise<OrionResponse<void>>;
    /**
     * Retrieve Subscription
     * @param subscriptionId subscription Id.
     */
    retrieve_Subscription(subscriptionId: string): Promise<OrionResponse<any>>;
    /**
     * Delete subscription
     * @param subscriptionId subscription Id.
     */
    delete_subscription(subscriptionId: string): Promise<OrionResponse<void>>;
    /**
     * Update Subscription
     * @param subscriptionId subscription Id.
     */
    update_Subscription(subscriptionId: string, content_Type: string, body: UpdateSubscriptionRequest): Promise<OrionResponse<void>>;
    /**
     * List Registrations
     * @param limit (optional) Limit the number of registrations to be retrieved
     * @param offset (optional) Skip a number of registrations
     * @param options (optional) Options dictionary
     */
    list_Registrations(limit?: number | null | undefined, offset?: number | null | undefined, options?: Options15 | null | undefined): Promise<OrionResponse<ListRegistrationsResponse[]>>;
    /**
     * Create Registration
     */
    create_Registration(content_Type: string, body: CreateRegistrationRequest): Promise<OrionResponse<void>>;
    /**
     * Retrieve Registration
     * @param registrationId registration Id.
     */
    retrieve_Registration(registrationId: string): Promise<OrionResponse<RetrieveRegistrationResponse>>;
    /**
     * Delete Registration
     * @param registrationId registration Id.
     */
    delete_Registration(registrationId: string): Promise<OrionResponse<void>>;
    /**
     * Update Registration
     * @param registrationId registration Id.
     */
    update_Registration(registrationId: string, content_Type: string, body: UpdateRegistrationRequest): Promise<OrionResponse<void>>;
    /**
     * Update
     * @param options (optional) Options dictionary
     */
    update(content_Type: string, body: UpdateRequest, options?: Options16 | null | undefined): Promise<OrionResponse<void>>;
    /**
     * Query
     * @param limit (optional) Limit the number of entities to be retrieved.
     * @param offset (optional) Skip a number of records.
     * @param orderBy (optional) Criteria for ordering results.
    See "Ordering Results" section for details.
     * @param options (optional) Options dictionary
     */
    query(content_Type: string, body: QueryRequest, limit?: number | null | undefined, offset?: number | null | undefined, orderBy?: string | null | undefined, options?: Options17 | null | undefined): Promise<OrionResponse<QueryResponse[]>>;
    /**
     * Notify
     * @param options (optional) Options dictionary
     */
    notify(content_Type: string, body: NotifyRequest, options?: Options18 | null | undefined): Promise<OrionResponse<void>>;
}

export class Client implements IClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://orion.lab.fiware.org/";
    }

    /**
     * Retrieve API Resources
     */
    retrieve_API_Resources(): Promise<OrionResponse<RetrieveApiResourcesResponse>> {
        let url_ = this.baseUrl + "/v2";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetrieve_API_Resources(_response);
        });
    }

    protected processRetrieve_API_Resources(response: Response): Promise<OrionResponse<RetrieveApiResourcesResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetrieveApiResourcesResponse.fromJS(resultData200);
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<RetrieveApiResourcesResponse>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * List Entities
     * @param id (optional) A comma-separated list of elements.
    Retrieve entities whose ID matches one of the elements in the list.
    Incompatible with `idPattern`.
     * @param type (optional) comma-separated list of elements.
    Retrieve entities whose type matches one of the elements in the list.
    Incompatible with `typePattern`.
     * @param idPattern (optional) A correctly formated regular expression.
    Retrieve entities whose ID matches the regular expression. Incompatible with `id`.
     * @param typePattern (optional) A correctly formated regular expression.
    Retrieve entities whose type matches the regular expression. Incompatible with `type`.
     * @param q (optional) A query expression, composed of a list of statements
    separated by `;`, i.e., q=statement1;statement2;statement3.
    See [Simple Query Language specification](#simple_query_language).
     * @param mq (optional) A query expression for attribute metadata,
    composed of a list of statements separated by `;`, i.e., mq=statement1;statement2;statement3.
    See [Simple Query Language specification](#simple_query_language).
     * @param georel (optional) Spatial relationship between matching entities and a
    reference shape. See [Geographical Queries](#geographical_queries).
     * @param geometry (optional) Geografical area to which the query is restricted.
    See [Geographical Queries](#geographical_queries).
     * @param coords (optional) List of latitude-longitude
    pairs of coordinates separated by ';'. See [Geographical Queries](#geographical_queries).
     * @param limit (optional) Limits the number of entities to be retrieved
     * @param offset (optional) Establishes the offset from where entities are retrieved
     * @param attrs (optional) Comma-separated list of attribute names whose data
    are to be included in the response.
    The attributes are retrieved in the order specified by this parameter. If this parameter is
    not included, the attributes are retrieved in arbitrary order.
    See "Filtering out attributes and metadata" section for more detail.
     * @param metadata (optional) A list of metadata names to include in the response.
    See "Filtering out attributes and metadata" section for more detail.
     * @param orderBy (optional) Criteria for ordering results.
    See "Ordering Results" section for details.
     * @param options (optional) Options dictionary
     */
    list_Entities(id?: string | null | undefined, type?: string | null | undefined, idPattern?: string | null | undefined, typePattern?: string | null | undefined, q?: string | null | undefined, mq?: string | null | undefined, georel?: string | null | undefined, geometry?: string | null | undefined, coords?: string | null | undefined, limit?: number | null | undefined, offset?: number | null | undefined, attrs?: string | null | undefined, metadata?: string | null | undefined, orderBy?: string | null | undefined, options?: Options2 | null | undefined): Promise<OrionResponse<ListEntitiesResponse[]>> {
        let url_ = this.baseUrl + "/v2/entities?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (idPattern !== undefined && idPattern !== null)
            url_ += "idPattern=" + encodeURIComponent("" + idPattern) + "&";
        if (typePattern !== undefined && typePattern !== null)
            url_ += "typePattern=" + encodeURIComponent("" + typePattern) + "&";
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (mq !== undefined && mq !== null)
            url_ += "mq=" + encodeURIComponent("" + mq) + "&";
        if (georel !== undefined && georel !== null)
            url_ += "georel=" + encodeURIComponent("" + georel) + "&";
        if (geometry !== undefined && geometry !== null)
            url_ += "geometry=" + encodeURIComponent("" + geometry) + "&";
        if (coords !== undefined && coords !== null)
            url_ += "coords=" + encodeURIComponent("" + coords) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset !== undefined && offset !== null)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (attrs !== undefined && attrs !== null)
            url_ += "attrs=" + encodeURIComponent("" + attrs) + "&";
        if (metadata !== undefined && metadata !== null)
            url_ += "metadata=" + encodeURIComponent("" + metadata) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList_Entities(_response);
        });
    }

    protected processList_Entities(response: Response): Promise<OrionResponse<ListEntitiesResponse[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListEntitiesResponse.fromJS(item));
            }
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<ListEntitiesResponse[]>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Create Entity
     * @param options (optional) Options dictionary
     */
    create_Entity(content_Type: string, body: CreateEntityRequest, options?: Options4 | null | undefined): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/entities?";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate_Entity(_response);
        });
    }

    protected processCreate_Entity(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Retrieve Entity
     * @param entityId Id of the entity to be retrieved
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param attrs (optional) Comma-separated list of attribute names whose
    data must be included in the response. The attributes are retrieved in the order specified by
    this parameter. See "Filtering out attributes and metadata" section for more detail.
    If this parameter is not included, the attributes are retrieved in arbitrary order, and all
    the attributes of the entity are included in the response.
     * @param metadata (optional) A list of metadata names to include in the response.
    See "Filtering out attributes and metadata" section for more detail.
     * @param options (optional) Options dictionary
     */
    retrieve_Entity(entityId: string, type?: string | null | undefined, attrs?: string | null | undefined, metadata?: string | null | undefined, options?: Options5 | null | undefined): Promise<OrionResponse<RetrieveEntityResponse>> {
        let url_ = this.baseUrl + "/v2/entities/{entityId}?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (attrs !== undefined && attrs !== null)
            url_ += "attrs=" + encodeURIComponent("" + attrs) + "&";
        if (metadata !== undefined && metadata !== null)
            url_ += "metadata=" + encodeURIComponent("" + metadata) + "&";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetrieve_Entity(_response);
        });
    }

    protected processRetrieve_Entity(response: Response): Promise<OrionResponse<RetrieveEntityResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetrieveEntityResponse.fromJS(resultData200);
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<RetrieveEntityResponse>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Remove Entity
     * @param entityId Id of the entity to be deleted
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     */
    remove_Entity(entityId: string, type?: string | null | undefined): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/entities/{entityId}?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemove_Entity(_response);
        });
    }

    protected processRemove_Entity(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Retrieve Entity Attributes
     * @param entityId Id of the entity to be retrieved
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param attrs (optional) Comma-separated list of attribute names whose
    data are to be included in the response. The attributes are retrieved in the order specified
    by this parameter.
    If this parameter is not included, the attributes are retrieved in arbitrary order, and all
    the attributes of the entity are included in the response.
    See "Filtering out attributes and metadata" section for more detail.
     * @param metadata (optional) A list of metadata names to include in the response.
    See "Filtering out attributes and metadata" section for more detail.
     * @param options (optional) Options dictionary
     */
    retrieve_Entity_Attributes(entityId: string, type?: string | null | undefined, attrs?: string | null | undefined, metadata?: string | null | undefined, options?: Options7 | null | undefined): Promise<OrionResponse<RetrieveEntityAttributesResponse>> {
        let url_ = this.baseUrl + "/v2/entities/{entityId}/attrs?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (attrs !== undefined && attrs !== null)
            url_ += "attrs=" + encodeURIComponent("" + attrs) + "&";
        if (metadata !== undefined && metadata !== null)
            url_ += "metadata=" + encodeURIComponent("" + metadata) + "&";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetrieve_Entity_Attributes(_response);
        });
    }

    protected processRetrieve_Entity_Attributes(response: Response): Promise<OrionResponse<RetrieveEntityAttributesResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetrieveEntityAttributesResponse.fromJS(resultData200);
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<RetrieveEntityAttributesResponse>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Replace all entity attributes
     * @param entityId Id of the entity in question.
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param options (optional) Operations options
     */
    replace_all_entity_attributes(entityId: string, content_Type: string, body: ReplaceAllEntityAttributesRequest, type?: string | null | undefined, options?: Options8 | null | undefined): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/entities/{entityId}/attrs?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReplace_all_entity_attributes(_response);
        });
    }

    protected processReplace_all_entity_attributes(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Update or Append Entity Attributes
     * @param entityId Entity id to be updated
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param options (optional) Operations options
     */
    update_or_Append_Entity_Attributes(entityId: string, content_Type: string, body: UpdateOrAppendEntityAttributesRequest, type?: string | null | undefined, options?: Options9 | null | undefined): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/entities/{entityId}/attrs?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate_or_Append_Entity_Attributes(_response);
        });
    }

    protected processUpdate_or_Append_Entity_Attributes(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Update Existing Entity Attributes
     * @param entityId Id of the entity to be updated
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param options (optional) Operations options
     */
    update_Existing_Entity_Attributes(entityId: string, content_Type: string, body: UpdateExistingEntityAttributesRequest, type?: string | null | undefined, options?: Options11 | null | undefined): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/entities/{entityId}/attrs?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate_Existing_Entity_Attributes(_response);
        });
    }

    protected processUpdate_Existing_Entity_Attributes(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Get attribute data
     * @param entityId Id of the entity
     * @param attrName Name of the attribute to be retrieved.
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     * @param metadata (optional) A list of metadata names to include in the response.
    See "Filtering out attributes and metadata" section for more detail.
     */
    get_attribute_data(entityId: string, attrName: string, type?: string | null | undefined, metadata?: string | null | undefined): Promise<OrionResponse<GetAttributeDataResponse>> {
        let url_ = this.baseUrl + "/v2/entities/{entityId}/attrs/{attrName}?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (attrName === undefined || attrName === null)
            throw new Error("The parameter 'attrName' must be defined.");
        url_ = url_.replace("{attrName}", encodeURIComponent("" + attrName));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (metadata !== undefined && metadata !== null)
            url_ += "metadata=" + encodeURIComponent("" + metadata) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet_attribute_data(_response);
        });
    }

    protected processGet_attribute_data(response: Response): Promise<OrionResponse<GetAttributeDataResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAttributeDataResponse.fromJS(resultData200);
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<GetAttributeDataResponse>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Update Attribute Data
     * @param entityId Id of the entity to update
     * @param attrName Attribute name
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     */
    update_Attribute_Data(entityId: string, attrName: string, content_Type: string, body: UpdateAttributeDataRequest, type?: string | null | undefined): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/entities/{entityId}/attrs/{attrName}?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (attrName === undefined || attrName === null)
            throw new Error("The parameter 'attrName' must be defined.");
        url_ = url_.replace("{attrName}", encodeURIComponent("" + attrName));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate_Attribute_Data(_response);
        });
    }

    protected processUpdate_Attribute_Data(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Remove a Single Attribute
     * @param entityId Id of the entity.
     * @param attrName Attribute name.
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     */
    remove_a_Single_Attribute(entityId: string, attrName: string, type?: string | null | undefined): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/entities/{entityId}/attrs/{attrName}?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (attrName === undefined || attrName === null)
            throw new Error("The parameter 'attrName' must be defined.");
        url_ = url_.replace("{attrName}", encodeURIComponent("" + attrName));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemove_a_Single_Attribute(_response);
        });
    }

    protected processRemove_a_Single_Attribute(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Get Attribute Value
     * @param entityId Id of the entity in question
     * @param attrName Name of the attribute to be retrieved.
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     */
    get_Attribute_Value(entityId: string, attrName: string, type?: string | null | undefined): Promise<OrionResponse<GetAttributeValueResponse>> {
        let url_ = this.baseUrl + "/v2/entities/{entityId}/attrs/{attrName}/value?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (attrName === undefined || attrName === null)
            throw new Error("The parameter 'attrName' must be defined.");
        url_ = url_.replace("{attrName}", encodeURIComponent("" + attrName));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet_Attribute_Value(_response);
        });
    }

    protected processGet_Attribute_Value(response: Response): Promise<OrionResponse<GetAttributeValueResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAttributeValueResponse.fromJS(resultData200);
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<GetAttributeValueResponse>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Update Attribute Value
     * @param entityId Id of the entity to be updated.
     * @param attrName Attribute name.
     * @param type (optional) Entity type, to avoid ambiguity in case there are several
    entities with the same entity id.
     */
    update_Attribute_Value(entityId: string, attrName: string, content_Type: string, body: UpdateAttributeValueRequest, type?: string | null | undefined): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/entities/{entityId}/attrs/{attrName}/value?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (attrName === undefined || attrName === null)
            throw new Error("The parameter 'attrName' must be defined.");
        url_ = url_.replace("{attrName}", encodeURIComponent("" + attrName));
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate_Attribute_Value(_response);
        });
    }

    protected processUpdate_Attribute_Value(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * List Entity Types
     * @param limit (optional) Limit the number of types to be retrieved.
     * @param offset (optional) Skip a number of records.
     * @param options (optional) Options dictionary.
     */
    list_Entity_Types(limit?: number | null | undefined, offset?: number | null | undefined, options?: Options13 | null | undefined): Promise<OrionResponse<ListEntityTypesResponse[]>> {
        let url_ = this.baseUrl + "/v2/types/?";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset !== undefined && offset !== null)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList_Entity_Types(_response);
        });
    }

    protected processList_Entity_Types(response: Response): Promise<OrionResponse<ListEntityTypesResponse[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListEntityTypesResponse.fromJS(item));
            }
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<ListEntityTypesResponse[]>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Retrieve entity type
     * @param entityType Entity Type
     */
    retrieve_entity_type(entityType: string): Promise<OrionResponse<RetrieveEntityTypeResponse>> {
        let url_ = this.baseUrl + "/v2/types/{entityType}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetrieve_entity_type(_response);
        });
    }

    protected processRetrieve_entity_type(response: Response): Promise<OrionResponse<RetrieveEntityTypeResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetrieveEntityTypeResponse.fromJS(resultData200);
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<RetrieveEntityTypeResponse>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * List Subscriptions
     * @param limit (optional) Limit the number of subscriptions to be retrieved
     * @param offset (optional) Skip a number of subscriptions
     * @param options (optional) Options dictionary
     */
    list_Subscriptions(limit?: number | null | undefined, offset?: number | null | undefined, options?: Options14 | null | undefined): Promise<OrionResponse<ListSubscriptionsResponse[]>> {
        let url_ = this.baseUrl + "/v2/subscriptions?";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset !== undefined && offset !== null)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList_Subscriptions(_response);
        });
    }

    protected processList_Subscriptions(response: Response): Promise<OrionResponse<ListSubscriptionsResponse[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListSubscriptionsResponse.fromJS(item));
            }
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<ListSubscriptionsResponse[]>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Create Subscription
     */
    create_Subscription(content_Type: string, body: CreateSubscriptionRequest): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate_Subscription(_response);
        });
    }

    protected processCreate_Subscription(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Retrieve Subscription
     * @param subscriptionId subscription Id.
     */
    retrieve_Subscription(subscriptionId: string): Promise<OrionResponse<any>> {
        let url_ = this.baseUrl + "/v2/subscriptions/{subscriptionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetrieve_Subscription(_response);
        });
    }

    protected processRetrieve_Subscription(response: Response): Promise<OrionResponse<any>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<any>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Delete subscription
     * @param subscriptionId subscription Id.
     */
    delete_subscription(subscriptionId: string): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/subscriptions/{subscriptionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete_subscription(_response);
        });
    }

    protected processDelete_subscription(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Update Subscription
     * @param subscriptionId subscription Id.
     */
    update_Subscription(subscriptionId: string, content_Type: string, body: UpdateSubscriptionRequest): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/subscriptions/{subscriptionId}";
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate_Subscription(_response);
        });
    }

    protected processUpdate_Subscription(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * List Registrations
     * @param limit (optional) Limit the number of registrations to be retrieved
     * @param offset (optional) Skip a number of registrations
     * @param options (optional) Options dictionary
     */
    list_Registrations(limit?: number | null | undefined, offset?: number | null | undefined, options?: Options15 | null | undefined): Promise<OrionResponse<ListRegistrationsResponse[]>> {
        let url_ = this.baseUrl + "/v2/registrations?";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset !== undefined && offset !== null)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList_Registrations(_response);
        });
    }

    protected processList_Registrations(response: Response): Promise<OrionResponse<ListRegistrationsResponse[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListRegistrationsResponse.fromJS(item));
            }
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<ListRegistrationsResponse[]>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Create Registration
     */
    create_Registration(content_Type: string, body: CreateRegistrationRequest): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/registrations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate_Registration(_response);
        });
    }

    protected processCreate_Registration(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Retrieve Registration
     * @param registrationId registration Id.
     */
    retrieve_Registration(registrationId: string): Promise<OrionResponse<RetrieveRegistrationResponse>> {
        let url_ = this.baseUrl + "/v2/registrations/{registrationId}";
        if (registrationId === undefined || registrationId === null)
            throw new Error("The parameter 'registrationId' must be defined.");
        url_ = url_.replace("{registrationId}", encodeURIComponent("" + registrationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetrieve_Registration(_response);
        });
    }

    protected processRetrieve_Registration(response: Response): Promise<OrionResponse<RetrieveRegistrationResponse>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetrieveRegistrationResponse.fromJS(resultData200);
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<RetrieveRegistrationResponse>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Delete Registration
     * @param registrationId registration Id.
     */
    delete_Registration(registrationId: string): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/registrations/{registrationId}";
        if (registrationId === undefined || registrationId === null)
            throw new Error("The parameter 'registrationId' must be defined.");
        url_ = url_.replace("{registrationId}", encodeURIComponent("" + registrationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete_Registration(_response);
        });
    }

    protected processDelete_Registration(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Update Registration
     * @param registrationId registration Id.
     */
    update_Registration(registrationId: string, content_Type: string, body: UpdateRegistrationRequest): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/registrations/{registrationId}";
        if (registrationId === undefined || registrationId === null)
            throw new Error("The parameter 'registrationId' must be defined.");
        url_ = url_.replace("{registrationId}", encodeURIComponent("" + registrationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate_Registration(_response);
        });
    }

    protected processUpdate_Registration(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Update
     * @param options (optional) Options dictionary
     */
    update(content_Type: string, body: UpdateRequest, options?: Options16 | null | undefined): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/op/update?";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Query
     * @param limit (optional) Limit the number of entities to be retrieved.
     * @param offset (optional) Skip a number of records.
     * @param orderBy (optional) Criteria for ordering results.
    See "Ordering Results" section for details.
     * @param options (optional) Options dictionary
     */
    query(content_Type: string, body: QueryRequest, limit?: number | null | undefined, offset?: number | null | undefined, orderBy?: string | null | undefined, options?: Options17 | null | undefined): Promise<OrionResponse<QueryResponse[]>> {
        let url_ = this.baseUrl + "/v2/op/query?";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset !== undefined && offset !== null)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuery(_response);
        });
    }

    protected processQuery(response: Response): Promise<OrionResponse<QueryResponse[]>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QueryResponse.fromJS(item));
            }
            return new OrionResponse(status, _headers, result200);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<QueryResponse[]>>(new OrionResponse(status, _headers, <any>null));
    }

    /**
     * Notify
     * @param options (optional) Options dictionary
     */
    notify(content_Type: string, body: NotifyRequest, options?: Options18 | null | undefined): Promise<OrionResponse<void>> {
        let url_ = this.baseUrl + "/v2/op/notify?";
        if (options !== undefined && options !== null)
            url_ += "options=" + encodeURIComponent("" + options) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
               
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotify(_response);
        });
    }

    protected processNotify(response: Response): Promise<OrionResponse<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return new OrionResponse(status, _headers, <any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrionResponse<void>>(new OrionResponse(status, _headers, <any>null));
    }
}

export class RetrieveApiResourcesResponse implements IRetrieveApiResourcesResponse {
    /** URL which points to the entities resource */
    entities_url!: string;
    /** URL which points to the types resource */
    types_url!: string;
    /** URL which points to the
subscriptions resource */
    subscriptions_url!: string;
    /** URL which points to the
registrations resource */
    registrations_url!: string;

    constructor(data?: IRetrieveApiResourcesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entities_url = _data["entities_url"];
            this.types_url = _data["types_url"];
            this.subscriptions_url = _data["subscriptions_url"];
            this.registrations_url = _data["registrations_url"];
        }
    }

    static fromJS(data: any): RetrieveApiResourcesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RetrieveApiResourcesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entities_url"] = this.entities_url;
        data["types_url"] = this.types_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["registrations_url"] = this.registrations_url;
        return data; 
    }
}

export interface IRetrieveApiResourcesResponse {
    /** URL which points to the entities resource */
    entities_url: string;
    /** URL which points to the types resource */
    types_url: string;
    /** URL which points to the
subscriptions resource */
    subscriptions_url: string;
    /** URL which points to the
registrations resource */
    registrations_url: string;
}

export enum Options {
    Count = "count",
    KeyValues = "keyValues",
    Values = "values",
    Unique = "unique",
}

export class ListEntitiesResponse implements IListEntitiesResponse {
    type!: string;
    id!: string;
    temperature?: any | undefined;
    speed?: any | undefined;

    constructor(data?: IListEntitiesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.temperature = _data["temperature"];
            this.speed = _data["speed"];
        }
    }

    static fromJS(data: any): ListEntitiesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntitiesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["temperature"] = this.temperature;
        data["speed"] = this.speed;
        return data; 
    }
}

export interface IListEntitiesResponse {
    type: string;
    id: string;
    temperature?: any | undefined;
    speed?: any | undefined;
}

export enum Options3 {
    KeyValues = "keyValues",
    Upsert = "upsert",
}

export class CreateEntityRequest implements ICreateEntityRequest {
    type!: string;
    id!: string;
    temperature!: any;
    humidity!: any;
    location!: any;

    constructor(data?: ICreateEntityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.temperature = _data["temperature"];
            this.humidity = _data["humidity"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): CreateEntityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEntityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["temperature"] = this.temperature;
        data["humidity"] = this.humidity;
        data["location"] = this.location;
        return data; 
    }
}

export interface ICreateEntityRequest {
    type: string;
    id: string;
    temperature: any;
    humidity: any;
    location: any;
}

export enum Options6 {
    KeyValues = "keyValues",
    Values = "values",
    Unique = "unique",
}

export class RetrieveEntityResponse implements IRetrieveEntityResponse {
    type!: string;
    id!: string;
    temperature!: any;
    humidity!: any;
    location!: any;

    constructor(data?: IRetrieveEntityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.temperature = _data["temperature"];
            this.humidity = _data["humidity"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): RetrieveEntityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RetrieveEntityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["temperature"] = this.temperature;
        data["humidity"] = this.humidity;
        data["location"] = this.location;
        return data; 
    }
}

export interface IRetrieveEntityResponse {
    type: string;
    id: string;
    temperature: any;
    humidity: any;
    location: any;
}

export class RetrieveEntityAttributesResponse implements IRetrieveEntityAttributesResponse {
    temperature!: any;
    humidity!: any;
    location!: any;

    constructor(data?: IRetrieveEntityAttributesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.temperature = _data["temperature"];
            this.humidity = _data["humidity"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): RetrieveEntityAttributesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RetrieveEntityAttributesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["temperature"] = this.temperature;
        data["humidity"] = this.humidity;
        data["location"] = this.location;
        return data; 
    }
}

export interface IRetrieveEntityAttributesResponse {
    temperature: any;
    humidity: any;
    location: any;
}

export enum Options10 {
    Append = "append",
    KeyValues = "keyValues",
}

export class UpdateOrAppendEntityAttributesRequest implements IUpdateOrAppendEntityAttributesRequest {
    ambientNoise!: any;

    constructor(data?: IUpdateOrAppendEntityAttributesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ambientNoise = _data["ambientNoise"];
        }
    }

    static fromJS(data: any): UpdateOrAppendEntityAttributesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrAppendEntityAttributesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ambientNoise"] = this.ambientNoise;
        return data; 
    }
}

export interface IUpdateOrAppendEntityAttributesRequest {
    ambientNoise: any;
}

export enum Options12 {
    KeyValues = "keyValues",
}

export class UpdateExistingEntityAttributesRequest implements IUpdateExistingEntityAttributesRequest {
    temperature!: any;
    seatNumber!: any;

    constructor(data?: IUpdateExistingEntityAttributesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.temperature = _data["temperature"];
            this.seatNumber = _data["seatNumber"];
        }
    }

    static fromJS(data: any): UpdateExistingEntityAttributesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExistingEntityAttributesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["temperature"] = this.temperature;
        data["seatNumber"] = this.seatNumber;
        return data; 
    }
}

export interface IUpdateExistingEntityAttributesRequest {
    temperature: any;
    seatNumber: any;
}

export class ReplaceAllEntityAttributesRequest implements IReplaceAllEntityAttributesRequest {
    temperature!: any;
    seatNumber!: any;

    constructor(data?: IReplaceAllEntityAttributesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.temperature = _data["temperature"];
            this.seatNumber = _data["seatNumber"];
        }
    }

    static fromJS(data: any): ReplaceAllEntityAttributesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReplaceAllEntityAttributesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["temperature"] = this.temperature;
        data["seatNumber"] = this.seatNumber;
        return data; 
    }
}

export interface IReplaceAllEntityAttributesRequest {
    temperature: any;
    seatNumber: any;
}

export class GetAttributeDataResponse implements IGetAttributeDataResponse {
    value!: number;
    type!: string;
    metadata!: any;

    constructor(data?: IGetAttributeDataResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.type = _data["type"];
            this.metadata = _data["metadata"];
        }
    }

    static fromJS(data: any): GetAttributeDataResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAttributeDataResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["type"] = this.type;
        data["metadata"] = this.metadata;
        return data; 
    }
}

export interface IGetAttributeDataResponse {
    value: number;
    type: string;
    metadata: any;
}

export class UpdateAttributeDataRequest implements IUpdateAttributeDataRequest {
    value!: number;
    metadata!: any;

    constructor(data?: IUpdateAttributeDataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.metadata = _data["metadata"];
        }
    }

    static fromJS(data: any): UpdateAttributeDataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAttributeDataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["metadata"] = this.metadata;
        return data; 
    }
}

export interface IUpdateAttributeDataRequest {
    value: number;
    metadata: any;
}

export class GetAttributeValueResponse implements IGetAttributeValueResponse {
    address!: string;
    zipCode!: number;
    city!: string;
    country!: string;

    constructor(data?: IGetAttributeValueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.city = _data["city"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): GetAttributeValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAttributeValueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["city"] = this.city;
        data["country"] = this.country;
        return data; 
    }
}

export interface IGetAttributeValueResponse {
    address: string;
    zipCode: number;
    city: string;
    country: string;
}

export class UpdateAttributeValueRequest implements IUpdateAttributeValueRequest {
    address!: string;
    zipCode!: number;
    city!: string;
    country!: string;

    constructor(data?: IUpdateAttributeValueRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.zipCode = _data["zipCode"];
            this.city = _data["city"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): UpdateAttributeValueRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAttributeValueRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["zipCode"] = this.zipCode;
        data["city"] = this.city;
        data["country"] = this.country;
        return data; 
    }
}

export interface IUpdateAttributeValueRequest {
    address: string;
    zipCode: number;
    city: string;
    country: string;
}

export enum Options20 {
    Count = "count",
    Values = "values",
}

export class ListEntityTypesResponse implements IListEntityTypesResponse {
    type!: string;
    attrs!: any;
    count!: number;

    constructor(data?: IListEntityTypesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.attrs = _data["attrs"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ListEntityTypesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntityTypesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["attrs"] = this.attrs;
        data["count"] = this.count;
        return data; 
    }
}

export interface IListEntityTypesResponse {
    type: string;
    attrs: any;
    count: number;
}

export class RetrieveEntityTypeResponse implements IRetrieveEntityTypeResponse {
    attrs!: any;
    count!: number;

    constructor(data?: IRetrieveEntityTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attrs = _data["attrs"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): RetrieveEntityTypeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RetrieveEntityTypeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attrs"] = this.attrs;
        data["count"] = this.count;
        return data; 
    }
}

export interface IRetrieveEntityTypeResponse {
    attrs: any;
    count: number;
}

export enum Options23 {
    Count = "count",
}

export class ListSubscriptionsResponse implements IListSubscriptionsResponse {
    id!: string;
    description!: string;
    subject!: any;
    notification!: any;
    expires!: string;
    status!: string;
    throttling!: number;

    constructor(data?: IListSubscriptionsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.subject = _data["subject"];
            this.notification = _data["notification"];
            this.expires = _data["expires"];
            this.status = _data["status"];
            this.throttling = _data["throttling"];
        }
    }

    static fromJS(data: any): ListSubscriptionsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListSubscriptionsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["subject"] = this.subject;
        data["notification"] = this.notification;
        data["expires"] = this.expires;
        data["status"] = this.status;
        data["throttling"] = this.throttling;
        return data; 
    }
}

export interface IListSubscriptionsResponse {
    id: string;
    description: string;
    subject: any;
    notification: any;
    expires: string;
    status: string;
    throttling: number;
}

export class CreateSubscriptionRequest implements ICreateSubscriptionRequest {
    description?: string | undefined;
    subject!: any;
    notification!: any;
    expires?: string | undefined;
    throttling?: number | undefined;

    constructor(data?: ICreateSubscriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.subject = _data["subject"];
            this.notification = _data["notification"];
            this.expires = _data["expires"];
            this.throttling = _data["throttling"];
        }
    }

    static fromJS(data: any): CreateSubscriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubscriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["subject"] = this.subject;
        data["notification"] = this.notification;
        data["expires"] = this.expires;
        data["throttling"] = this.throttling;
        return data; 
    }
}

export interface ICreateSubscriptionRequest {
    description?: string | undefined;
    subject: any;
    notification: any;
    expires?: string | undefined;
    throttling?: number | undefined;
}

export class UpdateSubscriptionRequest implements IUpdateSubscriptionRequest {
    expires!: string;

    constructor(data?: IUpdateSubscriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expires = _data["expires"];
        }
    }

    static fromJS(data: any): UpdateSubscriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSubscriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expires"] = this.expires;
        return data; 
    }
}

export interface IUpdateSubscriptionRequest {
    expires: string;
}

export class ListRegistrationsResponse implements IListRegistrationsResponse {
    id!: string;
    description!: string;
    dataProvided!: any;
    provider!: any;
    expires!: string;
    status!: string;
    forwardingInformation!: any;

    constructor(data?: IListRegistrationsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.dataProvided = _data["dataProvided"];
            this.provider = _data["provider"];
            this.expires = _data["expires"];
            this.status = _data["status"];
            this.forwardingInformation = _data["forwardingInformation"];
        }
    }

    static fromJS(data: any): ListRegistrationsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListRegistrationsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["dataProvided"] = this.dataProvided;
        data["provider"] = this.provider;
        data["expires"] = this.expires;
        data["status"] = this.status;
        data["forwardingInformation"] = this.forwardingInformation;
        return data; 
    }
}

export interface IListRegistrationsResponse {
    id: string;
    description: string;
    dataProvided: any;
    provider: any;
    expires: string;
    status: string;
    forwardingInformation: any;
}

export class CreateRegistrationRequest implements ICreateRegistrationRequest {
    description!: string;
    dataProvided!: any;
    provider!: any;

    constructor(data?: ICreateRegistrationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.dataProvided = _data["dataProvided"];
            this.provider = _data["provider"];
        }
    }

    static fromJS(data: any): CreateRegistrationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRegistrationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["dataProvided"] = this.dataProvided;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ICreateRegistrationRequest {
    description: string;
    dataProvided: any;
    provider: any;
}

export class RetrieveRegistrationResponse implements IRetrieveRegistrationResponse {
    id!: string;
    description!: string;
    dataProvided!: any;
    provider!: any;
    expires!: string;
    status!: string;
    forwardingInformation!: any;

    constructor(data?: IRetrieveRegistrationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.dataProvided = _data["dataProvided"];
            this.provider = _data["provider"];
            this.expires = _data["expires"];
            this.status = _data["status"];
            this.forwardingInformation = _data["forwardingInformation"];
        }
    }

    static fromJS(data: any): RetrieveRegistrationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RetrieveRegistrationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["dataProvided"] = this.dataProvided;
        data["provider"] = this.provider;
        data["expires"] = this.expires;
        data["status"] = this.status;
        data["forwardingInformation"] = this.forwardingInformation;
        return data; 
    }
}

export interface IRetrieveRegistrationResponse {
    id: string;
    description: string;
    dataProvided: any;
    provider: any;
    expires: string;
    status: string;
    forwardingInformation: any;
}

export class UpdateRegistrationRequest implements IUpdateRegistrationRequest {
    expires!: string;

    constructor(data?: IUpdateRegistrationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expires = _data["expires"];
        }
    }

    static fromJS(data: any): UpdateRegistrationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRegistrationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expires"] = this.expires;
        return data; 
    }
}

export interface IUpdateRegistrationRequest {
    expires: string;
}

export class UpdateRequest implements IUpdateRequest {
    actionType!: string;
    entities!: any[];

    constructor(data?: IUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.entities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionType = _data["actionType"];
            if (Array.isArray(_data["entities"])) {
                this.entities = [] as any;
                for (let item of _data["entities"])
                    this.entities!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionType"] = this.actionType;
        if (Array.isArray(this.entities)) {
            data["entities"] = [];
            for (let item of this.entities)
                data["entities"].push(item);
        }
        return data; 
    }
}

export interface IUpdateRequest {
    actionType: string;
    entities: any[];
}

export class QueryRequest implements IQueryRequest {
    entities!: any[];
    attrs!: string[];
    expression!: any;
    metadata!: string[];

    constructor(data?: IQueryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.entities = [];
            this.attrs = [];
            this.metadata = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entities"])) {
                this.entities = [] as any;
                for (let item of _data["entities"])
                    this.entities!.push(item);
            }
            if (Array.isArray(_data["attrs"])) {
                this.attrs = [] as any;
                for (let item of _data["attrs"])
                    this.attrs!.push(item);
            }
            this.expression = _data["expression"];
            if (Array.isArray(_data["metadata"])) {
                this.metadata = [] as any;
                for (let item of _data["metadata"])
                    this.metadata!.push(item);
            }
        }
    }

    static fromJS(data: any): QueryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new QueryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entities)) {
            data["entities"] = [];
            for (let item of this.entities)
                data["entities"].push(item);
        }
        if (Array.isArray(this.attrs)) {
            data["attrs"] = [];
            for (let item of this.attrs)
                data["attrs"].push(item);
        }
        data["expression"] = this.expression;
        if (Array.isArray(this.metadata)) {
            data["metadata"] = [];
            for (let item of this.metadata)
                data["metadata"].push(item);
        }
        return data; 
    }
}

export interface IQueryRequest {
    entities: any[];
    attrs: string[];
    expression: any;
    metadata: string[];
}

export class QueryResponse implements IQueryResponse {
    type!: string;
    id!: string;
    temperature!: any;

    constructor(data?: IQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.temperature = _data["temperature"];
        }
    }

    static fromJS(data: any): QueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["temperature"] = this.temperature;
        return data; 
    }
}

export interface IQueryResponse {
    type: string;
    id: string;
    temperature: any;
}

export class NotifyRequest implements INotifyRequest {
    subscriptionId!: string;
    data!: any[];

    constructor(data?: INotifyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
        }
    }

    static fromJS(data: any): NotifyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotifyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        return data; 
    }
}

export interface INotifyRequest {
    subscriptionId: string;
    data: any[];
}

/** Options dictionary */
export enum Options2 {
    Count = "count",
    KeyValues = "keyValues",
    Values = "values",
    Unique = "unique",
}

/** Options dictionary */
export enum Options4 {
    KeyValues = "keyValues",
    Upsert = "upsert",
}

/** Options dictionary */
export enum Options5 {
    KeyValues = "keyValues",
    Values = "values",
    Unique = "unique",
}

/** Options dictionary */
export enum Options7 {
    KeyValues = "keyValues",
    Values = "values",
    Unique = "unique",
}

/** Operations options */
export enum Options8 {
    KeyValues = "keyValues",
}

/** Operations options */
export enum Options9 {
    Append = "append",
    KeyValues = "keyValues",
}

/** Operations options */
export enum Options11 {
    KeyValues = "keyValues",
}

/** Options dictionary. */
export enum Options13 {
    Count = "count",
    Values = "values",
}

/** Options dictionary */
export enum Options14 {
    Count = "count",
}

/** Options dictionary */
export enum Options15 {
    Count = "count",
}

/** Options dictionary */
export enum Options16 {
    KeyValues = "keyValues",
}

/** Options dictionary */
export enum Options17 {
    Count = "count",
    KeyValues = "keyValues",
    Values = "values",
    Unique = "unique",
}

/** Options dictionary */
export enum Options18 {
    KeyValues = "keyValues",
}

export class OrionResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}